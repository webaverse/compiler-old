<!doctype html>
<html>
<head>
<style>
body {
  margin: 0;
}
.root {
}
.canvas {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
</style>
</head>
<body>
<div id=root className=root></div>
<canvas class=canvas id=canvas></canvas>
<script type="importmap">
{
  "imports": {
    "react": "./output/react.js",
    "react-all": "./output/react-all.js",
    "react-dom": "./output/react-dom.js",
    "@react-three/fiber": "./output/react-three-fiber.js",
    "@babel/standalone": "./output/babel.js",
    "three": "./three.module.js"
  }
}
</script>
<!-- <script src="./dist/browser.js"></script> -->
<!-- <script src="./dist/react.js"></script> -->
<script type=module>
// import * as React2 from 'react';
// import React from 'react';
// import ReactDOM from 'react-dom';
import {THREE, ReactDOM, ReactThreeFiber} from 'react-all';
// import {render} from '@react-three/fiber';
// import * as THREE from 'three';
import babelStandalone from '@babel/standalone';
import JSZip from './jszip.js';

// const {babelStandalone} = window.browser;
/* window.React = React;
window.ReactDOM = ReactDOM;
window.babelStandalone = babelStandalone;
window.reactThreeFiber = reactThreeFiber; */

function createPointerEvents(store) {
  // const { handlePointer } = createEvents(store)
  const handlePointer = key => e => {
    // const handlers = eventObject.__r3f.handlers;
    // console.log('handle pointer', key, e);
  };
  const names = {
    onClick: 'click',
    onContextMenu: 'contextmenu',
    onDoubleClick: 'dblclick',
    onWheel: 'wheel',
    onPointerDown: 'pointerdown',
    onPointerUp: 'pointerup',
    onPointerLeave: 'pointerleave',
    onPointerMove: 'pointermove',
    onPointerCancel: 'pointercancel',
    onLostPointerCapture: 'lostpointercapture',
  }

  return {
    connected: false,
    handlers: (Object.keys(names).reduce(
      (acc, key) => ({ ...acc, [key]: handlePointer(key) }),
      {},
    )),
    connect: (target) => {
      const { set, events } = store.getState()
      events.disconnect?.()
      set((state) => ({ events: { ...state.events, connected: target } }))
      Object.entries(events?.handlers ?? []).forEach(([name, event]) =>
        target.addEventListener(names[name], event, { passive: true }),
      )
    },
    disconnect: () => {
      const { set, events } = store.getState()
      if (events.connected) {
        Object.entries(events.handlers ?? []).forEach(([name, event]) => {
          if (events && events.connected instanceof HTMLElement) {
            events.connected.removeEventListener(names[name], event)
          }
        })
        set((state) => ({ events: { ...state.events, connected: false } }))
      }
    },
  }
}

window.onload = () => {

console.log('got react three fiber', ReactThreeFiber);

const fetchAndCompile = async (s, scriptUrl) => {
  const urlCache = {};
  const _mapUrl = async (u, scriptUrl) => {
    const cachedContent = urlCache[u];
    if (cachedContent !== undefined) {
      // return u;
      // nothing
    } else {
      const fullUrl = new URL(u, scriptUrl).href;
      const res = await fetch(fullUrl);
      if (res.ok) {
        let importScript = await res.text();
        importScript = await _mapScript(importScript, fullUrl);
        const p = new URL(fullUrl).pathname.replace(/^\//, '');
        urlCache[p] = importScript;
      } else {
        throw new Error('failed to load import url: ' + u);
      }
    }
  };
  const _mapScript = async (script, scriptUrl) => {
    // const r = /^(\s*import[^\n]+from\s*['"])(.+)(['"])/gm;
    // console.log('map script');
    const r = /((?:im|ex)port(?:["'\s]*[\w*{}\n\r\t, ]+from\s*)?["'\s])([@\w_\-\.\/]+)(["'\s].*);?$/gm;
    // console.log('got replacements', script, Array.from(script.matchAll(r)));
    const replacements = await Promise.all(Array.from(script.matchAll(r)).map(async match => {
      let u = match[2];
      // console.log('got u', u);
      if (/^\.+\//.test(u)) {
        await _mapUrl(u, scriptUrl);
      }
      return u;
    }));
    let index = 0;
    script = script.replace(r, function() {
      return arguments[1] + replacements[index++] + arguments[3];
    });
    const spec = babelStandalone.transform(script, {
      presets: ['react'],
      // compact: false,
    });
    script = spec.code;
    return script;
  };

  s = await _mapScript(s, scriptUrl);
  const p = new URL(scriptUrl).pathname.replace(/^\//, '');
  urlCache[p] = s;
  
  const zip = new JSZip();
  for (const p in urlCache) {
    const d = urlCache[p];
    console.log('add file', p);
    zip.file(p, d);
  }
  const ab = await zip.generateAsync({
    type: 'arraybuffer',
  });
  return new Uint8Array(ab);
};

(async () => {
  const s = `\
    import {React, Fragment, useState, useRef, Canvas, useFrame, useThree} from 'react-all';
  
    function Box(props) {
      // This reference will give us direct access to the THREE.Mesh object
      const mesh = useRef()
      // Set up state for the hovered and active state
      const [hovered, setHover] = useState(false)
      const [active, setActive] = useState(false)
      // Subscribe this component to the render-loop, rotate the mesh every frame
      useFrame((state, delta) => {
        mesh.current.rotation.x += 0.01;
      });
      // Return the view, these are regular Threejs elements expressed in JSX
      return (
        <mesh
          {...props}
          ref={mesh}
          scale={active ? 1.5 : 1}
          onClick={(event) => setActive(!active)}
          onPointerOver={(event) => setHover(true)}
          onPointerOut={(event) => setHover(false)}>
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} />
        </mesh>
      )
    }
    function Camera(props) {
      const ref = useRef()
      const set = useThree(state => state.set)
      // Make the camera known to the system
      useEffect(() => void set({ camera: ref.current }), [])
      // Update it every frame
      useFrame(() => ref.current.updateMatrixWorld())
      return <perspectiveCamera ref={ref} {...props} />
    }
    const render = () => {
      // console.log('render', r, React, r === React);
      return (
        <Fragment>
          {/*<Camera position={[0, 0, 10]} />*/}
          <perspectiveCamera />
          <ambientLight />
          <pointLight position={[10, 10, 10]} />
          <Box position={[-1.2, 0, 0]} />
          <Box position={[1.2, 0, 0]} />
        </Fragment>
      );
    };
    export default render;
  `;
  const zipData = await fetchAndCompile(s, 'https://example.com/index.js');
  
  const zip = await JSZip.loadAsync(zipData);
  console.log('load file 4', zip.files);

  {
    const indexJsFile = zip.files['index.js'];
    const data = await indexJsFile.async('uint8array');
    const s = new TextDecoder().decode(data);
  
    const root = document.getElementById('root');
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    const scene = new THREE.Scene();
    const camera = new THREE.Camera();

    console.log('got s', s);

    const b = new Blob([s], {
      type: 'application/javascript',
    });
    const u = URL.createObjectURL(b);
    const m = await import(u);
    const fn = m.default;
    console.log('got fn', fn);

    // const el = ReactDOM.render(fn(), root);
    const size = renderer.getSize(new THREE.Vector2());
    const el = ReactThreeFiber.render(fn(), canvas, {
      gl: renderer,
      size: {
        width: size.x,
        height: size.y,
      },
      events: createPointerEvents,
    });
    
    console.log('done render', el);
  }
  /* for (const fileName in zip.files) {
    
    console.log('got file', fileName, data, s);
  } */
})();

// import browser from './dist/browser2.js';
// window.browser = browser;
/* window.addEventListener('message', async e => {
  const zip = new JSZip();
  const spec = babelStandalone.transform(e.data, {
    presets: ['react'],
  });
  console.log('got spec', spec);
  const {code} = spec;
  const zipBuffer = new TextEncoder().encode(code);
  const file = new Blob([
    zipBuffer,
  ], {
    type: 'application/zip',
  });
  window.parent.postMessage({
    file,
  }, '*', [file]);
});
window.parent.addEventListener('message', e => {
  console.log('got result', e.data);
});
window.postMessage(new MessageEvent('message', {
  data: `<mesh x={7}/>`,
}), '*'); */

};
</script>
</body>
</html>